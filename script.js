"use strict";

// 1 завдання
console.log("start");

const promise1 = new Promise((resolve, reject) => {
  console.log(1);
  resolve(2);
});

promise1.then((res) => {
  console.log(res);
});

// В консолі буде: start, 1, 2
// start виконується відразу, тому що це синхронний код.
// Далі створюється проміс promise1, код всередині промісу виконується відразу,
// тобіш console.log(1);
// Викликається resolve(2) зі значенням 2, але метод then() ще не викликається,
// тому поки нічого не відбувається.
// у проміса викликається метод then() і як результат буде 2.

// 2 завдання

Promise.resolve(1)
  .then((x) => x + 1)
  .then((x) => {
    throw new Error("My Error");
  })
  .catch(() => 1)
  .then((x) => x + 1)
  .then((x) => console.log(x))
  .catch(console.error);

//   Створюється новий проміс зі значенням 1,
//   значення потрапляє до then() і результат стає 2,
//   другий then() приймає значення 2, але повертає помилку,
//   після цього проміс міняє свій стан на реджектед замість резолв,
//   catch() ловить помилку та повертає 1,
//   третій then() повертає 2,
//   ну і далі це значення виводиться в консоль.
//   catch() спрацює якщо буде помилка.

// 3 завдання

const promise = new Promise((res) => res(2));
promise
  .then((v) => {
    console.log(v);
    return v * 2;
  })
  .then((v) => {
    console.log(v);
    return v * 2;
  })
  .finally((v) => {
    console.log(v);
    return v * 2;
  })
  .then((v) => {
    console.log(v);
});

// Створюється проміс який має значення 2,
// перший then приймає значення 2 і виводить його в консоль,
// але повертає 4,
// другий then приймає значення 4 і виводить його в консоль,
// але повертає 8,
// якщо ми передаємо якесь значення в файналі,
// то воно буде undefined,
// останній then отримує значення з попереднього зен і виводить його в консоль.
// Результат: 2, 4, undefined, 8
